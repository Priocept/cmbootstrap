#!/bin/bash

# --------------------------------------------------------------------------------
##
## Configuration management bootstrap script.
##
## Version 1.2.91.
##
## Copyright Priocept Ltd.  All rights reserved.
##
# --------------------------------------------------------------------------------


# configuration constants
default_vcs_revision='HEAD'
default_tmp_dir='/tmp'
default_svn_version='subversion'
default_git_version='git'
default_ansible_version=''
gce_metadata_url='http://metadata/computeMetadata/v1/instance'
gce_metadata_header='Metadata-Flavor: Google'
amazon_linux_svn_17_sub_version='.22-1'
amazon_linux_svn_17_base_url='http://opensource.wandisco.com/centos/6/svn-1.7/RPMS/x86_64'
amazon_ec2_metadata_url='http://169.254.169.254/latest/user-data'
amazon_ec2_metadata_cmd='/opt/aws/bin/ec2-metadata'
ansible_main_file='main.yml'
ansible_init_file='init.yml'
ansible_config_file='config.yml'
git_tmp_path='.cm_git'
local_cm_dirname='cmbootstrap'
openstack_metadata_url="http://169.254.169.254/openstack/latest/meta_data.json"
openstack_metadata_timeout_seconds=5
openstack_metadata_config_drive_mount_dir="/mnt/config"
openstack_metadata_config_drive_mount_point="/dev/disk/by-label/config-2"
openstack_metadata_config_drive_metadata_file="${openstack_metadata_config_drive_mount_dir}/openstack/latest/meta_data.json"

# general configuration
# --------------------------------------------------------------------------------
function _configGeneral() {

    local _verbose_arg="-"
    local _compact_arg="-c"
    local _escape_arg="-e"
    local _arg1

    # process cmbootstrap compacting/escaping arguments
    _arg1=${args[0]}
    if [ "$_arg1" = "$_compact_arg" ]; then
        createCompact
        exit 0
    elif [ "$_arg1" = "$_escape_arg" ]; then
        createEscaped
        exit 0
    # process verbose output argument
    elif [ "$_arg1" = "$_verbose_arg" ]; then
        verbose_mode=1
    elif [ ! -z "$_arg1" ]; then
        echo "Invalid argument."
        exit 1
    else
        verbose_mode=0
    fi

    # pre-declaration of global variables
    configValue=''
    metaDataValue=''
    cm_disable_labeling_reported=''
    cm_labeling_unknown_platform_reported=''
    last_instance_label_set=''
    CM_GOOGLE_COMPUTE_ENGINE=''
    gcp_instance_name=''
    gcp_zone=''
    getAmazonEC2Tag_EnvironmentError=''
    getAmazonEC2Tag_Error=''
    ec2TagValue=''
    openStackMetaDataJsonRetrieved=''
    openStackMetaDataJson=''
    json=''

}


# path configuration
# --------------------------------------------------------------------------------
function _configPath() {

    script_dir=`dirname $0`
    cmbootstrap_dir=~/.cmbootstrap
    cmbootstrap_config_file='cmbootstrap.cfg'
    cmbootstrap_config_path="$script_dir/$cmbootstrap_config_file"
    timestamp=`date +%Y%m%d%H%M%S`
    cmbootstrap_log_path="$cmbootstrap_dir/cmbootstrap.log.$timestamp"
    cmbootstrap_err_path="$cmbootstrap_dir/cmbootstrap.err.$timestamp"
    cmbootstrap_old_dir="$cmbootstrap_dir/_old"
    vcs_local_dir="$cmbootstrap_dir/vcs"
    success_path="$cmbootstrap_dir/.success"
    packages_log_path="$cmbootstrap_dir/packages.log.$timestamp"
    packages_err_path="$cmbootstrap_dir/packages.err.$timestamp"

    export CM_VCS_LOCAL_DIR="$vcs_local_dir"

}


# initialization
# --------------------------------------------------------------------------------
function _init() {

    # prepare directory structure
    makeDirectory "$cmbootstrap_dir"
    makeDirectory "$cmbootstrap_old_dir"
    # move old logs
    mv -f "$cmbootstrap_dir"/*.log.* "$cmbootstrap_old_dir" 2>/dev/null
    mv -f "$cmbootstrap_dir"/*.err.* "$cmbootstrap_old_dir" 2>/dev/null
    rm -rf "$vcs_local_dir"
    makeDirectory "$vcs_local_dir"

    logInfo 'Directory structure created.'

    # Ansible requires that $HOME is defined
    HOME=~
    export HOME

}


# retrieve configuration management metadata
# --------------------------------------------------------------------------------
function _retrieveMetaData() {

    local _cm_disabled
    local _mandatory
    local _vcs_revision
    local _proxy_auth
    local _http_proxy
    local _https_proxy

    # initialize variables
    CM_AMAZON_EC2=''
    CM_AMAZON_LINUX=''
    CM_VMWARE=''
    CM_VIRTUALBOX=''

    # first check for disabled flag and terminate
    # early if configuration management is disabled
    getMetaData 'cm-disabled'
    _cm_disabled="$metaDataValue"
    if [ "$_cm_disabled" = "true" ]; then
        logInfo 'Configuration management disabled.'
        exit 0;
    fi

    # configure temporary directory
    configTemp

    # none of the metadata is mandatory if using
    # local configuration management files
    checkIfLocalCmFilesExist
    if [ "$?" -eq 1 ]; then
        logInfo "Local configuration management files found, metadata not mandatory."
        _mandatory=0
    else
        logInfo "Local configuration management files not found, metadata mandatory."
        _mandatory=1
    fi

    # retrieve metadata
    getMetaData 'cm-vcs-repo-base' _mandatory
    CM_VCS_REPO_BASE="$metaDataValue"
    if [ -z "$CM_VCS_REPO_BASE" ]; then
        fatalError 'Metadata cm-vcs-repo-base not defined, terminating.' 11
    fi
        getMetaData 'cm-vcs-base-path'
        CM_VCS_REPO_BASE_PATH="$metaDataValue"
        getMetaData 'cm-vcs-repo-type' _mandatory
        CM_VCS_REPO_TYPE="$metaDataValue"
    if [ -z "$CM_VCS_REPO_TYPE" ]; then
        fatalError 'Metadata cm-vcs-repo-type not defined, terminating.' 12
    fi
    getMetaData 'cm-vcs-accept-invalid-ssl'
    CM_VCS_ACCEPT_INVALID_SSL="$metaDataValue"
    getMetaData 'cm-vcs-svn-version'
    CM_VCS_SVN_VERSION="$metaDataValue"
    getMetaData 'cm-vcs-git-version'
    CM_VCS_GIT_VERSION="$metaDataValue"
    getMetaData 'cm-ansible-version'
    CM_ANSIBLE_VERSION="$metaDataValue"
    getMetaData 'cm-yum-proxy'
    CM_YUM_PROXY="$metaDataValue"
    getMetaData 'cm-yum-proxy-username'
    CM_YUM_PROXY_USERNAME="$metaDataValue"
    getMetaData 'cm-yum-proxy-password'
    CM_YUM_PROXY_PASSWORD="$metaDataValue"
    getMetaData 'cm-http-proxy'
    CM_HTTP_PROXY="$metaDataValue"
    getMetaData 'cm-http-proxy-username'
    CM_HTTP_PROXY_USERNAME="$metaDataValue"
    getMetaData 'cm-http-proxy-password'
    CM_HTTP_PROXY_PASSWORD="$metaDataValue"
    getMetaData 'cm-https-proxy'
    CM_HTTPS_PROXY="$metaDataValue"
    getMetaData 'cm-tmp-dir'
    CM_TMP_DIR="$metaDataValue"
    # reconfigure temporary directory if specified via meta data
    configTemp
    getMetaData 'cm-disable-labeling'
    CM_DISABLE_LABELING="$metaDataValue"
    getMetaData 'cm-vcs-username'
    CM_VCS_USERNAME="$metaDataValue"
    if [ -z "$CM_VCS_USERNAME" ]; then
        getMetaData 'cm-vcs-password'
        CM_VCS_PASSWORD="$metaDataValue"
    else
        # version control password is mandatory with username
        getMetaData 'cm-vcs-password' _mandatory
        CM_VCS_PASSWORD="$metaDataValue"
    fi
    getMetaData 'cm-ip-address'
    CM_IP_ADDRESS="$metaDataValue"
    getMetaData 'cm-netmask'
    CM_NETMASK="$metaDataValue"
    getMetaData 'cm-gateway'
    CM_GATEWAY="$metaDataValue"
    getMetaData 'cm-dns1'
    CM_DNS1="$metaDataValue"
    getMetaData 'cm-dns2'
    CM_DNS2="$metaDataValue"
    getMetaData 'cm-vcs-revision'
    _vcs_revision="$metaDataValue"
    getMetaData 'cm-vcs-branch'
    _vcs_branch="$metaDataValue"
    # Company name is mandatory
    getMetaData 'cm-organization' _mandatory
    CM_ORGANIZATION="$metaDataValue"
    # Project name is mandatory
    getMetaData 'cm-project' _mandatory
    CM_PROJECT="$metaDataValue"
    # Instance type is mandatory
    getMetaData 'cm-type' _mandatory
    CM_TYPE="$metaDataValue"
    getMetaData 'cm-hostname'
    CM_HOSTNAME="$metaDataValue"
    getMetaData 'cm-set-hostname'
    CM_SET_HOSTNAME="$metaDataValue"
    getMetaData 'cm-args'
    CM_ARGS="$metaDataValue"
    getMetaData 'cm-gcloud-debug'
    CM_GCLOUD_DEBUG="$metaDataValue"
    getMetaData 'cm-run-once'
    run_once="$metaDataValue"
    getMetaData 'cm-startup-delay'
    startup_delay="$metaDataValue"

    if [ ! -z "$CM_VCS_USERNAME" ] && [ -z "$CM_VCS_PASSWORD" ] && [[ _mandatory -eq 1 ]]; then
        fatalError 'Metadata cm-vcs-password not defined, terminating.' 13
    fi
    if [ -z "$CM_ORGANIZATION" ] && [[ _mandatory -eq 1 ]]; then
        fatalError 'Metadata cm-organization not defined, terminating.' 14
    fi
    if [ -z "$CM_PROJECT" ] && [[ _mandatory -eq 1 ]]; then
        fatalError 'Metadata cm-project not defined, terminating.' 15
    fi
    if [ -z "$CM_TYPE" ] && [[ _mandatory -eq 1 ]]; then
        fatalError 'Metadata cm-type not defined, terminating.' 16
    fi

    if [ -z "$_vcs_revision" ] && [[ _mandatory -eq 1 ]]; then
        logInfo "Metadata cm-vcs-revision not defined, using '$default_vcs_revision' revision."
        CM_VCS_REVISION="$default_vcs_revision"
    else
        CM_VCS_REVISION="$_vcs_revision"
    fi

    if [ ! -z "$_vcs_branch" ]; then
        CM_VCS_BRANCH="$_vcs_branch"
    fi

    # if HTTP proxy was specified but yum proxy was not
    # specified, then use the HTTP proxy value for both
    if [ ! -z "$CM_HTTP_PROXY" ]; then
        # if HTTPS proxy is not explicitly set, then
        # set it to be the same as the HTTP proxy
        if [ -z "$CM_HTTPS_PROXY" ]; then
            logInfo "Using HTTP proxy value for both HTTP and HTTPS proxies."
            CM_HTTPS_PROXY="$CM_HTTP_PROXY"
        fi
        if [ -z "$CM_YUM_PROXY" ]; then
            CM_YUM_PROXY="$CM_HTTP_PROXY"
            # also use HTTP proxy username and password as yum
            # proxy username and password, if specified
            if [ ! -z "$CM_HTTP_PROXY_USERNAME" ]; then
                CM_YUM_PROXY_USERNAME="$CM_HTTP_PROXY_USERNAME"
            fi
            if [ ! -z "$CM_HTTP_PROXY_PASSWORD" ]; then
                CM_YUM_PROXY_PASSWORD="$CM_HTTP_PROXY_PASSWORD"
            fi
        fi
    fi

    # if HTTPS proxy is set to dash value, then handle this
    # as no HTTPS proxy - this option allows HTTPS proxying
    # to be disabled while HTTP proxying is configured
    if [ "$CM_HTTPS_PROXY" = "-" ]; then
        logInfo "HTTPS proxy has been specified as none."
        CM_HTTPS_PROXY=''
    fi

    logInfo 'Instance metadata retrieved.'
    if [ ! -z "$CM_VCS_USERNAME" ]; then
        logInfo "VCS username: $CM_VCS_USERNAME"
    fi
    if [ ! -z "$CM_ORGANIZATION" ]; then
        logInfo "Company: $CM_ORGANIZATION"
    fi
    if [ ! -z "$CM_PROJECT" ]; then
        logInfo "Project: $CM_PROJECT"
    fi
    if [ ! -z "$CM_TYPE" ]; then
    logInfo "Type: $CM_TYPE"
    fi

    # terminate if configuration management has previously
    # completed successfully, unless "run once" is disabled
    if [ "$run_once" != "false" ] && [ -f "$success_path" ]; then
        # only terminate if not using local files
        checkIfLocalCmFilesExist
        if [ "$?" -ne 1 ]; then
            logInfo 'Configuration management successfully completed previously.'
            addInstanceLabel 'cmbootstrap-completed-previously'
            exit 0;
        fi
    fi

    # export metadata variables to make accessible by subsequent scripts
    export CM_VCS_REPO_BASE
    if [ ! -z "$CM_VCS_REPO_BASE_PATH" ]; then
        export CM_VCS_REPO_BASE_PATH
    fi
    export CM_VCS_REPO_TYPE
    if [ ! -z "$CM_VCS_ACCEPT_INVALID_SSL" ]; then
        export CM_VCS_ACCEPT_INVALID_SSL
    fi
    if [ ! -z "$CM_VCS_SVN_VERSION" ]; then
        export CM_VCS_SVN_VERSION
    fi
    if [ ! -z "$CM_VCS_GIT_VERSION" ]; then
        export CM_VCS_GIT_VERSION
    fi
    if [ ! -z "$CM_VCS_USERNAME" ]; then
        export CM_VCS_USERNAME
    fi
    if [ ! -z "$CM_VCS_PASSWORD" ]; then
        export CM_VCS_PASSWORD
    fi
    if [ ! -z "$CM_VCS_REVISION" ]; then
        export CM_VCS_REVISION
    fi
    export CM_ORGANIZATION
    export CM_PROJECT
    export CM_TYPE
    if [ ! -z "$CM_HOSTNAME" ]; then
        export CM_HOSTNAME
    fi
    if [ ! -z "$CM_SET_HOSTNAME" ]; then
        export CM_SET_HOSTNAME
    fi
    if [ ! -z "$CM_ARGS" ]; then
        export CM_ARGS
    fi
    if [ ! -z "$CM_GOOGLE_COMPUTE_ENGINE" ]; then
        export CM_GOOGLE_COMPUTE_ENGINE
    fi
    if [ ! -z "$CM_AMAZON_EC2" ]; then
        export CM_AMAZON_EC2
    fi
    if [ ! -z "$CM_AMAZON_LINUX" ]; then
        export CM_AMAZON_LINUX
    fi
    if [ ! -z "$CM_VMWARE" ]; then
        export CM_VMWARE
    fi
    if [ ! -z "$CM_VIRTUALBOX" ]; then
        export CM_VIRTUALBOX
    fi
    if [ ! -z "$CM_YUM_PROXY" ]; then
        export CM_YUM_PROXY
    fi
    if [ ! -z "$CM_HTTP_PROXY" ]; then
        export CM_HTTP_PROXY
    fi
    if [ ! -z "$CM_HTTPS_PROXY" ]; then
        export CM_HTTPS_PROXY
    fi
    if [ ! -z "$CM_HTTP_PROXY_USERNAME" ]; then
        export CM_HTTP_PROXY_USERNAME
    fi
    if [ ! -z "$CM_HTTP_PROXY_PASSWORD" ]; then
        export CM_HTTP_PROXY_PASSWORD
    fi

    # insert proxy authentication details into proxy address if required
    _proxy_auth="$CM_HTTP_PROXY_USERNAME:$CM_HTTP_PROXY_PASSWORD@"
    if [ ! -z "$CM_HTTP_PROXY" ] && [ ! -z "$CM_HTTP_PROXY_USERNAME" ]; then
        _http_proxy="${CM_HTTP_PROXY/http\:\/\//http://$_proxy_auth}"
    else
        _http_proxy="$CM_HTTP_PROXY"
    fi
    if [ ! -z "$CM_HTTPS_PROXY" ] && [ ! -z "$CM_HTTP_PROXY_USERNAME" ]; then
        _https_proxy="${CM_HTTPS_PROXY/http\:\/\//http://$_proxy_auth}"
    else
        _https_proxy="$_http_proxy"
    fi

    # export proxy environment variables in both upper and lower
    # case, as different software expects different variations
    if [ ! -z "$CM_HTTP_PROXY" ]; then
        export HTTP_PROXY="$_http_proxy"
        export http_proxy="$_http_proxy"
    fi
    if [ ! -z "$CM_HTTPS_PROXY" ]; then
        export https_proxy="$_https_proxy"
        export HTTPS_PROXY="$_https_proxy"
    fi

    # delay before proceeding further, if a delay is specified
    if [ ! -z "$startup_delay" ]; then

        # if delay string ends in R, then randomize delay between
        # zero and the value proceeding the R character
        startup_randomized=$(echo -n "$startup_delay" | tail -c 1)
        if [ "$startup_randomized" = "R" ]; then
            # remove R character from end to extract delay value
            startup_delay=${startup_delay::-1}
        fi
        if [ "$startup_delay" -eq "$startup_delay" ] 2>/dev/null; then
            if [ "$startup_randomized" = "R" ]; then
                startup_delay=$(echo $(( $RANDOM % $startup_delay )))
            fi
            logInfo "Delaying configuration management startup by $startup_delay seconds..."
            sleep "$startup_delay"
        else
            logInfo "Invalid configuration management startup delay value '$startup_delay'."
        fi

    fi

}


# temporary storage configuration
# --------------------------------------------------------------------------------
function configTemp() {

    # alternative temp directory can be passed in as a function parameter
    if [ -z "$CM_TMP_DIR" ]; then
        tmp_dir="$default_tmp_dir"
    else
        tmp_dir="$CM_TMP_DIR"
    fi

    makeDirectory "$tmp_dir"
    git_clone_tmp_path="$tmp_dir/$git_tmp_path"
    configLocalCm

    # set TMPDIR environment variable to control download
    # location used by Ansible get_url module
    export TMPDIR="$tmp_dir"

}


# version control configuration
# --------------------------------------------------------------------------------
function _configVcs() {

    if [ "$CM_VCS_REPO_TYPE" = "Subversion" ]; then
        configSubversion
    elif [ "$CM_VCS_REPO_TYPE" = "Git" ]; then
        configGit
    else
        fatalError "Invalid version control type '$CM_VCS_REPO_TYPE'.", 21
    fi

}


# Subversion configuration
# --------------------------------------------------------------------------------
function configSubversion() {

    # use default Subversion package if not specified in config file or metadata
    if [ -z "$CM_VCS_SVN_VERSION" ]; then
        svn_version="$default_svn_version"
    else
        svn_version="$CM_VCS_SVN_VERSION"
    fi

}


# Git configuration
# --------------------------------------------------------------------------------
function configGit() {

    # use default Git package if not specified in config file or metadata
    if [ -z "$CM_VCS_GIT_VERSION" ]; then
        git_version="$default_git_version"
    else
        git_version="$CM_VCS_GIT_VERSION"
    fi

    git_params=( -c http.sslVerify=false )

}


# configuration management configuration
# --------------------------------------------------------------------------------
function _configCm() {

    configAnsible

}


# Ansible configuration
# --------------------------------------------------------------------------------
function configAnsible() {

    # use default Ansible package if not specified in config file or metadata
    if [ -z "$CM_ANSIBLE_VERSION" ]; then
        ansible_version="$default_ansible_version"
    else
        ansible_version="$CM_ANSIBLE_VERSION"
    fi

    ansible_log_path="$cmbootstrap_dir/ansible.log.$timestamp"
    ansible_err_path="$cmbootstrap_dir/ansible.err.$timestamp"
    ansible_hosts_path="/etc/ansible"
    ansible_hosts_file="$ansible_hosts_path/hosts"

}


# Local configuration management configuration
# --------------------------------------------------------------------------------
function configLocalCm() {

    local_cm_dir="$tmp_dir/$local_cm_dirname"
    local_ansible_main_file="$local_cm_dir/$ansible_main_file"
    local_ansible_init_file="$local_cm_dir/$ansible_init_file"
}

# hostname configuration
# --------------------------------------------------------------------------------
function _configHostname() {

    # do nothing if "set hostname" not enabled
    if [ "$CM_SET_HOSTNAME" != "true" ]; then
        logInfo 'Hostname setting not enabled, retaining default hostname.'
        return
    fi

    # do nothing if the instance hostname was not specified
    if [ -z "$CM_HOSTNAME" ]; then
        logInfo 'Instance hostname not configured, retaining default hostname.'
        return
    fi

    # check that hostnamectl command is installed and executable
    command -v hostnamectl >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        fatalError 'Unable to set hostname, hostnamectl command not available, terminating.' 22
    fi

    # change the hostname
    logInfo "Setting hostname to $CM_HOSTNAME"
    hostnamectl set-hostname "$CM_HOSTNAME"

}


# prerequisites install
# --------------------------------------------------------------------------------
function _installPrerequisites() {

    # install and prepare package management
    installPackageManagement

    # install configuration management
    installCm

    # install version control
    installVersionControl

}


# configuration management install
# --------------------------------------------------------------------------------
function installPackageManagement() {

    # check if yum command is installed and executable
    command -v yum >/dev/null 2>&1

    # prepare yum if it is installed
    if [ $? -eq 0 ]; then

        # configure yum proxy
        configYumProxy

        yum_clean_all_path="$cmbootstrap_dir/.yum_clean_all"

        # perform yum clean all, but only once per environment
        if [ ! -f "$yum_clean_all_path" ]; then
            logInfo 'Running yum clean all...'
            if [ "$verbose_mode" -eq 1 ]; then
                yum clean all
            else
                yum clean all >>"$packages_log_path" 2>>"$packages_err_path"
            fi
            if [ $? -ne 0 ]; then
                fatalError "yum clean all failed." 121
            fi
            touch "$yum_clean_all_path"
        else
            logInfo 'yum clean all was run previously.'
        fi

        # install yum utils
        logInfo 'Installing yum utils...'
        installPackage "yum-utils"

        if [ "$verbose_mode" -eq 1 ]; then
            yum-complete-transaction
            # ensure EPEL repository is enabled - disabled by default on Amazon Linux
            yum-config-manager --enable epel/x86_64
        else
            yum-complete-transaction >>"$packages_log_path" 2>>"$packages_err_path"
            # ensure EPEL repository is enabled - disabled by default on Amazon Linux
            yum-config-manager --enable epel/x86_64 >>"$packages_log_path" 2>>"$packages_err_path"
        fi

        # EPEL packages only apply for CentOS/yum
        logInfo 'Installing Extra Packages for Enterprise Linux...'
        installPackage "epel-release"

    fi

    # check if apt-get installed and executable
    command -v apt-get >/dev/null 2>&1

    # wait for dpkg locks if apt-get is installed
    if [ $? -eq 0 ]; then

        logInfo "Waiting for dpkg locks..."
        command -v fuser >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            logInfo "fuser not available."
            return
        fi

        while fuser '/var/lib/dpkg/lock' >/dev/null 2>&1; do
            logInfo "Waiting for lock..."
            sleep 5
        done

    fi

}


# yum proxy configuration
# --------------------------------------------------------------------------------
function configYumProxy() {

    local _proxy_line
    local _yum_conf

    if [ ! -z "$CM_YUM_PROXY" ]; then

        logInfo "Configuring yum proxy server '$CM_YUM_PROXY'."

        _yum_conf='/etc/yum.conf'
        _proxy_line="proxy=$CM_YUM_PROXY"
        _proxy_username_line="proxy_username=$CM_YUM_PROXY_USERNAME"
        _proxy_password_line="proxy_password=$CM_YUM_PROXY_PASSWORD"

        # add proxy entry to yum.conf if not already present
        if grep -q "^$_proxy_line" "$_yum_conf" ; then
            logInfo "Proxy entry already exists in $_yum_conf."
        else
            # comment out any previous proxy lines
            sed -i 's/^proxy=/#proxy=/' "$_yum_conf"
            echo "proxy=$CM_YUM_PROXY" >> "$_yum_conf"
            logInfo "Proxy entry added to $_yum_conf."
        fi
        # add proxy username entry to yum.conf if not already present
        if grep -q "^$_proxy_username_line" "$_yum_conf" ; then
            logInfo "Proxy username entry already exists in $_yum_conf."
        else
            # comment out any previous proxy username lines
            sed -i 's/^proxy_username=/#proxy_username=/' "$_yum_conf"
            echo "$_proxy_username_line" >> "$_yum_conf"
            logInfo "Proxy username entry added to $_yum_conf."
        fi
        # add proxy password entry to yum.conf if not already present
        if grep -q "^$_proxy_password_line" "$_yum_conf" ; then
            logInfo "Proxy password entry already exists in $_yum_conf."
        else
            # comment out any previous proxy password lines
            sed -i 's/^proxy_password=/#proxy_password=/' "$_yum_conf"
            echo "$_proxy_password_line" >> "$_yum_conf"
            logInfo "Proxy password entry added to $_yum_conf."
        fi

        # configure yum repositories to only use base URLs and not mirror list
        sed -i 's/^mirrorlist=/#mirrorlist=/' /etc/yum.repos.d/*.repo
        sed -i 's/^#baseurl=/baseurl=/' /etc/yum.repos.d/*.repo

        logInfo "yum repository base URLs enabled."

    fi

}


# configuration management install
# --------------------------------------------------------------------------------
function installCm() {

    installAnsible

}


# version control install
# --------------------------------------------------------------------------------
function installVersionControl() {

    if [ "$CM_VCS_REPO_TYPE" = "Subversion" ]; then
        installSubversion
    elif [ "$CM_VCS_REPO_TYPE" = "Git" ]; then
        installGit
    else
        fatalError "Invalid version control type '$CM_VCS_REPO_TYPE'.", 31
    fi

}


# fetch configuration management files
# --------------------------------------------------------------------------------
function _fetchFiles() {

    # use local files if available - used during configuration management development
    checkIfLocalCmFilesExist
    if [ "$?" -eq 1 ]; then
        logInfo "Local configuration management files found, skipping fetch from version control."
        return
    else
        logInfo "Local configuration management files not found, fetching from version control."
    fi

    cmFetchStartupFiles

}


# fetch main configuration management files
# --------------------------------------------------------------------------------
function cmFetchStartupFiles() {

    local _repo_base

    cd "$vcs_local_dir"

    logInfo 'Fetching configuration management files...'

    # build path to configuration management file location based on metadata
    CM_VCS_REPO_SUB_PATH="$CM_ORGANIZATION/$CM_PROJECT/$CM_TYPE"

    # if CM_VCS_REPO_BASE_PATH is set, append on to the end of the repo base URL
    if [ ! -z "$CM_VCS_REPO_BASE_PATH" ]; then
        logInfo "Using repo base '$CM_VCS_REPO_BASE' plus repo base path '$CM_VCS_REPO_BASE_PATH'"
        _repo_base="$CM_VCS_REPO_BASE/$CM_VCS_REPO_BASE_PATH"
    else
        logInfo "Using repo base '$CM_VCS_REPO_BASE'"
        _repo_base="$CM_VCS_REPO_BASE"
    fi

    CM_VCS_REPO_PATH="$_repo_base/$CM_VCS_REPO_SUB_PATH/$CM_HOSTNAME"

    # now retrieve instance specific configuration management file from
    # version control if it exists, otherwise attempt generic version
    if [ ! -z "$CM_HOSTNAME" ]; then
        logInfo 'Looking for instance specific configuration management file...'
        vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_main_file"
    fi

    if [ $? -eq 0 ] && [ ! -z "$CM_HOSTNAME" ]; then

        logInfo 'Instance specific configuration management file found.'
        vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_main_file"
        # attempt to retrieve configuration management init file
        # if alongside the main configuration management file
        vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_init_file"
        if [ $? -eq 0 ]; then
            logInfo 'Configuration management initialization file found, retrieving.'
            vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_init_file"
        fi
        vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_config_file"
        if [ $? -eq 0 ]; then
            logInfo 'Config playbook file found, retrieving.'
            vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_config_file"
        fi

    else

        logInfo 'Looking for type generic configuration management file...'

        CM_VCS_REPO_PATH="$_repo_base/$CM_VCS_REPO_SUB_PATH"

        vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_main_file"

        if [ $? -eq 0 ]; then
            logInfo 'Type generic configuration management file found.'
            vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_main_file"
            # attempt to retrieve configuration management initialization file
            vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_init_file"
            if [ $? -eq 0 ]; then
                logInfo 'Configuration management initialization file found, retrieving.'
                vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_init_file"
            fi
            vcsCheckFileExists "$CM_VCS_REPO_PATH/$ansible_config_file"
            if [ $? -eq 0 ]; then
                logInfo 'Configuration management config file found, retrieving.'
                vcsRetrieveFile "$CM_VCS_REPO_PATH/$ansible_config_file"
            fi
        else
            # the following condition may occur either because the configuration management
            # files do not exist, or because of an invalid version control configuration
            fatalError 'Type generic configuration management file not available, terminating.' 41
        fi

    fi

    # export discovered configuration management VCS path to make accessible to subsequent scripts
    export CM_VCS_REPO_PATH
    export CM_VCS_REPO_SUB_PATH

    # check the configuration management file now exists locally
    if [ ! -f "$vcs_local_dir/$ansible_main_file" ]; then
        fatalError 'Unable to retrieve configuration management file, terminating.' 42
    fi

}


# run configuration management initialization file - this file is executed before
# the main configuration management file, which may be dependent on steps that are
# performed by the initialization file
# --------------------------------------------------------------------------------
function _runInitFile() {

    local _cmPath
    local _errorCode

    # use local file if available - used for configuration management development
    checkIfLocalCmInitFileExists
    if [ $? -eq 1 ]; then
        _cmPath="$local_ansible_init_file"
        _message="Executing local configuration management init file $_cmPath."
        # update CM_VCS_LOCAL_DIR to point to local cm directory if in use
        export CM_VCS_LOCAL_DIR="$local_cm_dir"
    else
        _cmPath="$vcs_local_dir/$ansible_init_file"
        _message="Executing configuration management init file $_cmPath."
    fi
    logInfo "$_message"
    if [ "$verbose_mode" -ne 1 ]; then
        echo "$_message" >>"$ansible_log_path"
    fi

    if [ -f "$_cmPath" ]; then
        cmRun "$_cmPath"
        _errorCode=$?
        if [ "$_errorCode" != 0 ]; then
            fatalError "Configuration management '$_cmPath' failed." "$_errorCode"
        else
            logInfo 'Configuration management initialization complete.'
        fi
    else
        logInfo 'Configuration management initialization file not found.'
    fi

}


# generic VCS functions
# --------------------------------------------------------------------------------
function vcsCheckFileExists() {

    if [ "$CM_VCS_REPO_TYPE" = "Subversion" ]; then
        subversionCheckFileExists $1
    elif [ "$CM_VCS_REPO_TYPE" = "Git" ]; then
        gitCheckFileExists $1
    else
        fatalError "Invalid version control type '$CM_VCS_REPO_TYPE'.", 51
    fi

}
function vcsRetrieveFile() {

    if [ "$CM_VCS_REPO_TYPE" = "Subversion" ]; then
        subversionRetrieveFile $1
    elif [ "$CM_VCS_REPO_TYPE" = "Git" ]; then
        gitRetrieveFile $1
    else
        fatalError "Invalid version control type '$CM_VCS_REPO_TYPE'.", 52
    fi

}


# run main configuration management file
# --------------------------------------------------------------------------------
function _runMainFile() {

    local _cmPath
    local _message
    local _errorCode

    # use local file if available - used for configuration management development
    checkIfLocalCmMainFileExists
    if [ $? -eq 1 ]; then
        _cmPath="$local_ansible_main_file"
        _message="Executing local configuration management file $_cmPath."
        # update CM_VCS_LOCAL_DIR to point to local cm directory if in use
        export CM_VCS_LOCAL_DIR="$local_cm_dir"
    else
        _cmPath="$vcs_local_dir/$ansible_main_file"
        _message="Executing main configuration management file $_cmPath."
    fi
    logInfo "$_message"
    if [ "$verbose_mode" -ne 1 ]; then
        echo "$_message" >>"$ansible_log_path"
    fi

    # execute the configuration management file
    cmRun "$_cmPath"
    _errorCode=$?
    if [ "$_errorCode" != 0 ]; then
        fatalError 'Configuration management failed.' "$_errorCode"
    else
        # create file to record success - this is
        # ignored if run-once is set to false
        touch "$success_path"
        logInfo 'Configuration management complete.'
    fi

}


# configuration management file runner
# --------------------------------------------------------------------------------
function cmRun() {

    windowsToUnixFormat "$1"
    ansibleRun $1

}


# static IP address configuration
# --------------------------------------------------------------------------------
function _setStaticIpAddress() {

    local _firstInterface
    local _ifcfgFile

    # as a minimum, IP address and netmask must be provided to trigger static IP address configuration
    if [ -z "$CM_IP_ADDRESS" ] && [ -z "$CM_NETMASK" ]; then
        return
    fi

    _firstInterface=$(find /sys/class/net/* ! -name 'lo' -printf "%f\n" | head -1)
    if [ -z "$_firstInterface" ]; then
        fatalError "Unable to retrieve first network interface name, terminating." 101
    fi

    _ifcfgFile="/etc/sysconfig/network-scripts/ifcfg-$_firstInterface"

    # interface name, ip address and netmask are all mandatory
    echo -e "DEVICE=$_firstInterface\nBOOTPROTO=static\nIPADDR=$CM_IP_ADDRESS\nNETMASK=$CM_NETMASK\nONBOOT=yes\nNM_CONTROLLED=no\n" > "$_ifcfgFile"
    # gateway, DNS 1 and DNS 2 are optional and not added to the ifcfg- file if not provided
    if [ ! -z "$CM_GATEWAY" ]; then
        echo -e "GATEWAY=$CM_GATEWAY\n" >> "$_ifcfgFile"
    fi
    if [ ! -z "$CM_DNS1" ]; then
        echo -e "DNS1=$CM_DNS1\n" >> "$_ifcfgFile"
    fi
    if [ ! -z "$CM_DNS2" ]; then
        echo -e "DNS2=$CM_DNS2\n" >> "$_ifcfgFile"
    fi

    logInfo "Static IP address $CM_IP_ADDRESS configured for interface $_firstInterface, restarting network..."
    restartNetwork
    if [ $? -ne 0 ]; then
        fatalError "Error setting static IP address $CM_IP_ADDRESS - network restart failed, terminating." 102
    fi
    logInfo "Network restarted."

}

function restartNetwork() {
    service network restart
}


# generic (auto-detecting) metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaData() {

    local _metaDataName=$1
    local _appendedCmArgsValue=""

    getMetaDataWithAutoDetect "$_metaDataName"

    if [ "$_metaDataName" == "cm-args" ] && [ -z "$metaDataValue" ]; then
        logInfo "cm-args value not found, checking cm-args-N values..."
        for i in {1..100}
        do
            getMetaDataWithAutoDetect "cm-args-$i"
            if [ ! -z "$metaDataValue" ]; then
                _appendedCmArgsValue+="$metaDataValue"
            else
                logInfo "cm-args-$i value not found."
                break
            fi
        done
        metaDataValue="$_appendedCmArgsValue"
        logInfo "Combined cm-args value='$metaDataValue'."
    fi

 }

# generic (auto-detecting) metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataWithAutoDetect() {

    local _metaDataName=$1
    local _mandatory=$2

    # first check for presence of metadata in config file, which overrides any other values
    if [ -f "$cmbootstrap_config_path" ]; then
        readConfigFileValue "$_metaDataName"
        if [ ! -z "$configValue" ]; then
            metaDataValue="$configValue"
            return
        fi
    fi

    # detect Google Compute Engine instance
    checkGoogleComputeAvailable
    if [ $? -eq 0 ]; then
        getMetaDataGoogleComputeEngine "$_metaDataName" "$_mandatory"
        return
    fi

    # detect Amazon EC2 instance
    checkAmazonEC2Available
    if [ $? -eq 0 ]; then
        if [ -z "$CM_AMAZON_EC2" ]; then
            logInfo "Amazon EC2 detected."
        fi
        CM_AMAZON_EC2=1
        checkAmazonLinuxAvailable
        if [ $? -eq 0 ]; then
            if [ -z "$CM_AMAZON_LINUX" ]; then
                logInfo "Amazon Linux detected."
            fi
            CM_AMAZON_LINUX=1
        else
            CM_AMAZON_LINUX=0
        fi
        getMetaDataAmazonEC2 "$_metaDataName" "$_mandatory"
        return
    fi

    # detect VMware instance
    checkVMwareAvailable
    if [ $? -eq 0 ]; then
        if [ -z "$CM_VMWARE" ]; then
            logInfo "VMware detected."
        fi
        CM_VMWARE=1
        getMetaDataVMware "$_metaDataName" "$_mandatory"
        return
    fi

    # detect VirtualBox instance
    checkVirtualBoxAvailable
    if [ $? -eq 0 ]; then
        if [ -z "$CM_VIRTUALBOX" ]; then
            logInfo "VirtualBox detected."
        fi
        CM_VIRTUALBOX=1
        getMetaDataVirtualBox "$_metaDataName" "$_mandatory"
        return
    fi

    # detect OpenStack instance
    checkOpenStackAvailable
    if [ $? -eq 0 ]; then
        if [ -z "$CM_OPENSTACK" ]; then
            logInfo "Openstack detected."
        fi
        CM_OPENSTACK=1
        getMetaDataOpenStack "$_metaDataName" "$_mandatory"
        return
    fi

    if [ -z "$CM_ENVIRONMENT_VARIABLES" ]; then
        CM_ENVIRONMENT_VARIABLES=1
        logInfo "Virtualization not detected, checking environment variables."
    fi

    # finally attempt to retrieve metadata via environment variables
    getMetaDataEnvironment "$_metaDataName" "$_mandatory"

}

# generic (auto-detecting) labeling functions
# --------------------------------------------------------------------------------
function addInstanceLabel() {

    local _labelName=$1

    if [ "$CM_DISABLE_LABELING" = "true" ]; then
        if [ -z "$cm_disable_labeling_reported" ]; then
            logInfo "Instance labeling disabled."
        fi
        cm_disable_labeling_reported=1
        return
    fi

    # detect Google Compute Engine instance
    checkGoogleComputeAvailable
    if [ $? -eq 0 ]; then
        addInstanceLabelGoogleComputeEngine "$_labelName"
        if [ $? -eq 0 ]; then
            # remove last label if recorded
            if [ ! -z "$last_instance_label_set"  ]; then
                removeInstanceLabel "$last_instance_label_set"
            fi
            last_instance_label_set="$_labelName"
        fi
    else
        if [ -z "$cm_labeling_unknown_platform_reported" ]; then
            logInfo "Unable to add instance label '$_labelName', unsupported platform."
        fi
        cm_labeling_unknown_platform_reported=1
        return
    fi

}
function removeInstanceLabel() {

    local _labelName=$1
    local _ignoreMissing=$2

    # detect Google Compute Engine instance
    checkGoogleComputeAvailable
    if [ $? -eq 0 ]; then
        removeInstanceLabelGoogleComputeEngine "$_labelName" "$_ignoreMissing"
    else
        if [ -z "$cm_labeling_unknown_platform_reported" ]; then
            logInfo "Unable to remove instance label, unsupported platform."
        fi
        cm_labeling_unknown_platform_reported=1
        return
    fi

}


# Google Compute Engine metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataGoogleComputeEngine() {

    local _metaDataName=$1
    local _mandatory=$2

    metaDataValue=$(curl --fail --header "$gce_metadata_header" "$gce_metadata_url/attributes/$_metaDataName" 2>/dev/null)
    if [ $? -ne 0 ]; then

        metaDataValue=''

        # terminate if parameter was marked as mandatory
		if [ "$_mandatory" = "1" ]; then
			fatalError "Error retrieving '$_metaDataName' mandatory metadata value from Google Compute Engine, terminating." 61
		fi

    elif [ ! -z "$metaDataValue" ]; then
    	logInfo "Metadata $_metaDataName='$metaDataValue' retrieved."
    fi

}


# Google Compute Engine labelling functions
# --------------------------------------------------------------------------------
function addInstanceLabelGoogleComputeEngine() {

    local _labelName=$1
    local _httpLog=$2
    local _zone
    local _gcloudParams

    getGoogleComputeEngineInstanceAndZone
    logInfo "Adding Google Compute Engine label '$_labelName' to instance '$gcp_instance_name' (zone '$gcp_zone')..."
    if [ $? -ne 0 ]; then
        logInfo "Unable to retrieve Google Compute Engine instance and zone."
        return 1
    fi

    _gcloudParams=( compute instances add-labels "$gcp_instance_name" --zone="$gcp_zone" --labels="$_labelName=" )

    if [ "$_httpLog" = "1" ]; then
        _gcloudParams=( '--log-http' '--verbosity=debug' "${_gcloudParams[@]}" )
    fi
    if [ "$verbose_mode" -eq 1 ]; then
        gcloud "${_gcloudParams[@]}"
    else
        gcloud "${_gcloudParams[@]}"  >>"$cmbootstrap_log_path" 2>&1
    fi
    if [ $? -ne 0 ]; then
        logInfo "Error adding Google Compute Engine label '$_labelName'."
        # if labelling failed and gcloud debug option is enabled, retry with HTTP logging enabled to allow diagnosis
        if [ "$_httpLog" != "1" ] && [ "$CM_GCLOUD_DEBUG" = "true" ]; then
            logInfo "Retrying Google Compute Engine labelling with HTTP logging enabled..."
            addInstanceLabelGoogleComputeEngine "$_labelName" '1'
            return "$?"
        fi
        return 2
    else
        logInfo "Google Compute Engine label '$_labelName' added."
    fi

}
function removeInstanceLabelGoogleComputeEngine() {

    local _labelName=$1
    local _ignoreMissing=$2

    getGoogleComputeEngineInstanceAndZone
    logInfo "Removing Google Compute Engine label '$_labelName' from instance '$gcp_instance_name' (zone '$gcp_zone')..."
    if [ $? -ne 0 ]; then
        logInfo "Unable to retrieve Google Compute Engine instance and zone."
        return 1
    fi
    if [ ! -z "$_ignoreMissing" ] && [ "$_ignoreMissing" -eq 1 ]; then
        if [ "$verbose_mode" -eq 1 ]; then
            gcloud compute instances remove-labels "$gcp_instance_name" --zone="$gcp_zone" --labels="$_labelName" 2>/dev/null
        else
            gcloud compute instances remove-labels "$gcp_instance_name" --zone="$gcp_zone" --labels="$_labelName" >>"$cmbootstrap_log_path" 2>/dev/null
        fi
        if [ $? -eq 0 ]; then
            logInfo "Google Compute Engine label '$_labelName' removed."
        fi
    else
        if [ "$verbose_mode" -eq 1 ]; then
            gcloud compute instances remove-labels "$gcp_instance_name" --zone="$gcp_zone" --labels="$_labelName"
        else
            gcloud compute instances remove-labels "$gcp_instance_name" --zone="$gcp_zone" --labels="$_labelName" >>"$cmbootstrap_log_path" 2>&1
        fi
        if [ $? -ne 0 ]; then
            logInfo "Unable to remove Google Compute Engine label '$_labelName'."
        else
            logInfo "Google Compute Engine label '$_labelName' removed."
        fi
    fi

}
function getGoogleComputeEngineInstanceAndZone() {

    if [ -z "$gcp_instance_name" ]; then
        logInfo "Retrieving GCP instance name..."
        gcp_instance_name=$(curl --fail --header "$gce_metadata_header" "$gce_metadata_url/hostname" 2>/dev/null  | cut -d. -f1)
        if [ $? -ne 0 ] || [ -z  "$gcp_instance_name" ]; then
            logInfo "Error retrieving Google Compute Engine instance name."
            return 1
        fi
    fi
    if [ -z "$gcp_zone" ]; then
        gcp_zone=$(curl --fail --header "$gce_metadata_header" "$gce_metadata_url/zone" 2>/dev/null  | cut -d/ -f4)
        if [ $? -ne 0 ] || [ -z  "$gcp_zone" ]; then
            logInfo "Error retrieving Google Compute Engine zone."
            return 2
        fi
    fi

}


# VMware metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataVMware() {

    local _metaDataName=$1
    local _mandatory=$2

	# the vmtools command will return 'No value found' if the metadata value does not
	# exist - this message does not need to be logged and is redirected to /dev/null
	if [ "$verbose_mode" -eq 1 ]; then
        metaDataValue=$(vmtoolsd --cmd "info-get guestinfo.$_metaDataName" 2>/dev/null)
    else
        metaDataValue=$(vmtoolsd --cmd "info-get guestinfo.$_metaDataName" 2>/dev/null) >>"$cmbootstrap_log_path"
    fi
    if [ $? -ne 0 ]; then

    	metaDataValue=''

		# terminate if parameter was marked as mandatory
		if [ "$_mandatory" = 1 ]; then
			fatalError "Error retrieving '$_metaDataName' mandatory metadata value from VMware config, terminating." 62
		fi

    elif [ ! -z "$metaDataValue" ]; then
    	logInfo "Metadata $_metaDataName='$metaDataValue' retrieved."
    fi

}


# VirtualBox metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataVirtualBox() {

    local _metaDataName=$1
    local _mandatory=$2

    metaDataValue=$(VBoxControl --nologo guestproperty get "$1")

    if [ $? -ne 0 ] || [ "$metaDataValue" == "No value set!" ]; then

    	metaDataValue=''

		# terminate if parameter was marked as mandatory
		if [ "$_mandatory" = 1 ]; then
			fatalError "Error retrieving '$_metaDataName' mandatory metadata value from VirtualBox config, terminating." 63
		fi

	else

	    # remove  "Value: " prefix from returned metadata value
	    metaDataValue=$(echo "$metaDataValue" | sed s/Value\:[[:space:]]//g)

    	logInfo "Metadata $_metaDataName='$metaDataValue' retrieved."

    fi

}

# OpenStack metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataOpenStack() {

	# JSON field separator can either be a colon, a comma, a right curly brace, or end of file
	local _fs1="\"[[:space:]]*[:,][[:space:]]*\""
	local _fs2="\"}"
	local _fs3="\"$"

	local _metaDataName=$1
	local _mandatory=$2

    # retrieve OpenStack metadata JSON, this contains all the metadata in a single
    # response, so only need to retrieve if no previous attempt to retrieve
    if [[ "openStackMetaDataJsonRetrieved" -ne 1 ]]; then
        getOpenStackMetaDataJson
        openStackMetaDataJsonRetrieved=1
	    openStackMetaDataJson="$json"
    fi

    # simple JSON parsing - this makes various assumptions about the JSON format
    # but should work for OpenStack metadata, and does not require external tools
	metaDataValue=$(echo "$openStackMetaDataJson" | grep -o "\"$_metaDataName\"\w*:\w*.*[^\\]\"" | awk -F"$_fs1|$_fs2|$_fs3" '{print $2}')

    # terminate if parameter was marked as mandatory
    if [ -z "$metaDataValue" ] && [ "$_mandatory" = 1 ]; then
        fatalError "Error retrieving '$_metaDataName' mandatory metadata value from OpenStack, terminating." 65
    elif [ ! -z "$metaDataValue" ]; then
    	logInfo "Metadata $_metaDataName='$metaDataValue' retrieved."
    fi

}
function getOpenStackMetaDataJson() {

    # check for OpenStack config drive first
    logInfo "Checking for OpenStack config drive..."
    if [ -f "$openstack_metadata_config_drive_metadata_file" ]; then
        logInfo "Config drive already mounted."
    else
        mkdir -p "$openstack_metadata_config_drive_mount_dir" > /dev/null 2>&1
        mount "$openstack_metadata_config_drive_mount_point" "$openstack_metadata_config_drive_mount_dir" > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            logInfo "Config drive mounted."
            if [ ! -f "$openstack_metadata_config_drive_metadata_file" ]; then
                logInfo "Config drive metadata file not found."
            fi
        else
            logInfo "Config drive not available."
        fi
    fi
    if [ -f "$openstack_metadata_config_drive_metadata_file" ]; then
        json=$(cat "$openstack_metadata_config_drive_metadata_file")
        if [ ! -z "$json" ]; then
            logInfo "OpenStack config drive metadata retrieved."
            return
        else
            logInfo "OpenStack config drive metadata was empty."
        fi
    fi

    # attempt metadata retrieval via HTTP if config drive metadata not available
    logInfo "Retrieving OpenStack metadata from '$openstack_metadata_url'..."
    json=$(curl --max-time "$openstack_metadata_timeout_seconds" "$openstack_metadata_url" 2>/dev/null)
    if [ -z "$json" ]; then
        logInfo "OpenStack HTTP metadata not available."
    else
        logInfo "OpenStack HTTP metadata retrieved."
    fi

}


# Amazon EC2 metadata retrieval function
#
# Note: EC2 metadata can either be defined in the "user-data" field, as
# multiple lines and in name=value format, and where metadata names use
# underscore rather than hyphen, or alternatively using EC2 tags with
# standard naming format.
# --------------------------------------------------------------------------------
function getMetaDataAmazonEC2() {

    local _exitCode
    local _userData
    local _metaDataName=$1
    local _mandatory=$2

    # first attempt to retrieve the metadata in the form of an AWS tag
    getAmazonEC2Tag "$_metaDataName"
    _exitCode=$?
    if [ "$_exitCode" -eq "0" ] && [ ! -z "$ec2TagValue" ]; then
        metaDataValue="$ec2TagValue"
        logInfo "Metadata $_metaDataName='$metaDataValue' retrieved from EC2 tag."
        return
    elif [ "$_exitCode" -ne "0" ]; then
        if [[ "$getAmazonEC2Tag_Error" -ne 1 ]]; then
            logInfo "Error retrieving metadata $_metaDataName from EC2 tag (error code $_exitCode)."
        fi
        getAmazonEC2Tag_Error=1
    fi

    # if metadata was not found as a tag, retrieve the EC2 user data and
    # look for the metadata in the form of bash variable assignments
    _userData=$(curl --fail "$amazon_ec2_metadata_url" 2>/dev/null)
    if [ $? -ne 0 ]; then

        metaDataValue=''

        # terminate if parameter was marked as mandatory
		if [ "$_mandatory" = "1" ]; then
            fatalError 'Error retrieving user data from Amazon EC2, terminating.' 64
		fi

    else

        # swap '-' for '_' in meta data name - this is required for EC2 user
        # data because '-' is not a valid character in a shell variable name
        _metaDataName=$(echo "$_metaDataName" | tr '-' '_')

        # extract metadata value from overall user data contents, assuming name=value format at start of a line
        metaDataValue=$(echo "$_userData" | grep "^$_metaDataName=" | awk -F'=' '{ val = index($0,"=");print substr($0,val+1)}')

        if [ ! -z "$metaDataValue" ]; then
    	    logInfo "Metadata $_metaDataName='$metaDataValue' retrieved from EC2 user data."
        fi

    fi

}


# Amazon EC2 tag retrieval function
#
# Note: This function will only work if the EC2 instance has been assigned a role
# which includes the "ec2:DescribeTags" permission.
# --------------------------------------------------------------------------------
function getAmazonEC2Tag() {

    local _tagName=$1
    local _ec2InstanceId
    local _filter_params
    local _aws_region
    local _tagValues

    # skip if AWS CLI commands were previously detected as not available
    if [[ "$getAmazonEC2Tag_EnvironmentError" -eq 1 ]]; then
        return 1
    fi

    # check that aws and ec2-metadata commands are installed
    command -v aws >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        logInfo 'aws command not installed, EC2 tags not available.'
        getAmazonEC2Tag_EnvironmentError=1
        return 2
    fi
    command -v "$amazon_ec2_metadata_cmd" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        logInfo "$amazon_ec2_metadata_cmd command not installed, EC2 tags not available."
        getAmazonEC2Tag_EnvironmentError=1
        return 3
    fi

    # retrieve EC2 instance ID
    _ec2InstanceId=$("$amazon_ec2_metadata_cmd" -i | cut -d ' ' -f2)
    if [ -z "$_ec2InstanceId" ]; then
        logInfo 'EC2 instance ID not available, cannot retrieve EC2 tags.'
        return 4
    fi

    # retrieve AWS region
    _aws_region=$("$amazon_ec2_metadata_cmd" --availability-zone | cut -d ' ' -f2)
    _aws_region=${_aws_region%?}
    if [ -z "$_aws_region" ]; then
        logInfo 'AWS region not available, cannot retrieve EC2 tags.'
        return 5
    fi

    # set aws ec2 describe-tags filter parameters
    _filter_params=( --filters "Name=key,Values=$_tagName" "Name=resource-type,Values=instance" "Name=resource-id,Values=$_ec2InstanceId" )

    # retrieve tags
    _tagValues=$(aws ec2 describe-tags --output text --region "$_aws_region" "${_filter_params[@]}")
    if [ $? -ne 0 ]; then
        getAmazonEC2Tag_EnvironmentError=1
        logInfo 'Error retrieving EC2 tag value.  Check EC2 role includes ec2:DescribeTags permission.'
        return 6
    fi

    # extract required tag value
    ec2TagValue=$(echo "$_tagValues" | cut -f5)

}


# Environment variable based metadata retrieval function
# --------------------------------------------------------------------------------
function getMetaDataEnvironment() {

    local _metaDataName=$1
    local _mandatory=$2
    local _metaDataEnvName

    # the expected environment variable name is the metadata name, converted
    # to uppercase and with '-' replaced with '_'
    _metaDataEnvName=$(echo "$_metaDataName" | tr '[:lower:]' '[:upper:]')
    _metaDataEnvName=$(echo "$_metaDataEnvName" | tr '-' '_')
    metaDataValue=$(printenv "$_metaDataEnvName")

    # no mandatory check is performed, as undefined and defined-as-blank are the same for environment variables
    if [ ! -z "$metaDataValue" ]; then
        logInfo "Metadata $_metaDataName found in environment variable."
    fi

}


# VMware availability check function
# --------------------------------------------------------------------------------
function checkVMwareAvailable() {

    # check for availability of vmtoolsd RPC calls rather than simply the
    # availability of the executable, as VMware Tools may be installed on
    # VMware/VirtualBox common VM images
    vmtoolsd --cmd "info-set guestinfo.vmware-detect 1" >/dev/null 2>&1

}


# VirtualBox availability check function
# --------------------------------------------------------------------------------
function checkVirtualBoxAvailable() {

    # detect VirtualBox instances via VBoxControl executable
    VBoxControl version >/dev/null 2>&1

}


# Google Compute Engine availability check function
# --------------------------------------------------------------------------------
function checkGoogleComputeAvailable() {

    # detect GCE instances via script runner executable
    google_metadata_script_runner >/dev/null 2>&1

    # non-zero exit code still indicates google_metadata_script_runner presence, unless value is 127
    if [ $? -ne 127 ]; then
        if [ -z "$CM_GOOGLE_COMPUTE_ENGINE" ]; then
            logInfo "Google Compute Engine detected."
        fi
        CM_GOOGLE_COMPUTE_ENGINE=1
        return 0
    else
        return 1
    fi
}


# Amazon EC2 and Amazon Linux availability check functions
# --------------------------------------------------------------------------------
function checkAmazonEC2Available() {

    # detect Amazon EC2 instances via /sys/hypervisor/uuid
    if [ -f /sys/hypervisor/uuid ] && [ `head -c 3 /sys/hypervisor/uuid` == ec2 ]; then
        return 0
    else
        return 1
    fi

}
function checkAmazonLinuxAvailable() {

    local _system
    # use /etc/system-release contents to determine if running on Amazon Linux
    if [ ! -f "/etc/system-release" ]; then
        return 1
    fi

    _system=$(cat /etc/system-release)
    if [[ "$_system" == "Amazon Linux "* ]]; then
        return 0
    else
        return 1
    fi

}


# OpenStack availability check function
# --------------------------------------------------------------------------------
function checkOpenStackAvailable() {
	command -v dmidecode >/dev/null 2>&1 || { return 1; }
	dmidecode -t system | grep 'Manufacturer\|Product' | grep 'OpenStack' > /dev/null
	return $?
}


# package installer
# --------------------------------------------------------------------------------
function installPackage() {

    local _packageName=$1

    if [ -z "$_packageName" ]; then
        fatalError 'Package name not provided.' 71
    fi

    # check if yum command is installed and executable
    command -v yum >/dev/null 2>&1

    # install package using yum if available
    if [ $? -eq 0 ]; then

        logInfo "Installing yum package '$_packageName'..."
        if [ "$verbose_mode" -eq 1 ]; then
            yum -y install "$_packageName"
        else
            yum -y install "$_packageName" >>"$packages_log_path" 2>>"$packages_err_path"
        fi

        # terminate if package not available
        if [ ! $? -eq 0 ]; then
            fatalError "Package '$_packageName' not available." 72
        fi

        return
    fi

    # if yum was not found, check for apt-get command instead
    command -v apt-get >/dev/null 2>&1
    if [ $? -eq 0 ]; then

        if [ "$verbose_mode" -eq 1 ]; then
            apt-get -y install "$_packageName"
        else
            apt-get -y install "$_packageName" >>"$packages_log_path" 2>>"$packages_err_path"
        fi

        # terminate if package not available
        if [ ! $? -eq 0 ]; then
            fatalError "Package '$_packageName' not available." 73
        fi

        return

    fi

    fatalError 'Package manager not available.' 74

}


# Subversion functions
# --------------------------------------------------------------------------------
function installSubversion() {

    local _amazon_linux_svn_17
    local _amazon_linux_svn_17_url

    logInfo 'Installing Subversion...'

    # if running on Amazon Linux and Subversion 1.7 is specified, then
    # download it manually as not available via Amazon yum repository
    if [ ! -z "$CM_AMAZON_LINUX" ] && [ "$CM_AMAZON_LINUX" -eq 1 ] && [ "$CM_VCS_SVN_VERSION" == "subversion-1.7" ]; then

        logInfo "Performing Amazon-specific Subversion 1.7 install."

        # details for manual download if Subversion 1.7 is configured
        _amazon_linux_svn_17="$svn_version$amazon_linux_svn_17_sub_version.x86_64.rpm"
        _amazon_linux_svn_17_url="$amazon_linux_svn_17_base_url/$_amazon_linux_svn_17"

        # uninstall pre-installed Amazon subversion package

        logInfo "Removing existing Subversion installation."
        if [ "$verbose_mode" -eq 1 ]; then
            yum -y remove subversion subversion-libs
        else
            yum -y remove subversion subversion-libs >>"$packages_log_path" 2>>"$packages_err_path"
        fi

        # check if already downloaded to avoid unnecessary download
        logInfo "Checking for existing $svn_version installation."
        if [ "$verbose_mode" -eq 1 ]; then
            yum list installed "$svn_version"
        else
            yum list installed "$svn_version" >>"$packages_log_path" 2>>"$packages_err_path"
        fi

        if [ $? -eq 0 ]; then
            logInfo "$svn_version already installed."
        else
            logInfo "Downloading $_amazon_linux_svn_17_url."
            if [ "$verbose_mode" -eq 1 ]; then
                wget "$_amazon_linux_svn_17_url" -P /tmp/
            else
                wget "$_amazon_linux_svn_17_url" -P /tmp/ >>"$packages_log_path" 2>>"$packages_err_path"
            fi
            if [ $? -ne 0 ]; then
                fatalError "Error downloading Subversion 1.7 from $_amazon_linux_svn_17_url.", 81
            fi
            logInfo "Installing Subversion 1.7 from /tmp/$_amazon_linux_svn_17."
            if [ "$verbose_mode" -eq 1 ]; then
                yum -y install "/tmp/$_amazon_linux_svn_17"
            else
                yum -y install "/tmp/$_amazon_linux_svn_17" >>"$packages_log_path" 2>>"$packages_err_path"
            fi
            if [ $? -ne 0 ]; then
                fatalError "Error installing Subversion 1.7 from /tmp/$_amazon_linux_svn_17.", 82
            fi
            rm -f "/tmp/$_amazon_linux_svn_17"
        fi

    else

        installPackage "$svn_version"

    fi

}
function subversionCheckFileExists {

    local _svn_params
    local _file=$1

    logInfo "Checking for Subversion file: $_file (revision $CM_VCS_REVISION)"

    _svn_params=( --non-interactive )
    if [ ! -z "$CM_VCS_USERNAME" ]; then
        _svn_params+=( --no-auth-cache --username "$CM_VCS_USERNAME" --password "$CM_VCS_PASSWORD"  )
    fi

    # if using SSL with invalid certificate, need to pass --trust-server-cert argument
    if [[ "$_file" =~ ^https\:\/\/.* ]] && [ "$CM_VCS_ACCEPT_INVALID_SSL" = "true" ]; then
        _svn_params+=('--trust-server-cert')
    fi
    if [ "$verbose_mode" -eq 1 ]; then
        svn ls -r "$CM_VCS_REVISION" "${_svn_params[@]}" "$_file"
    else
        svn ls -r "$CM_VCS_REVISION" "${_svn_params[@]}" "$_file" >/dev/null 2>&1
    fi

}
function subversionRetrieveFile {

    local _svn_params
    local _file=$1

    logInfo "Retrieving Subversion file: $_file (revision $CM_VCS_REVISION)"

    _svn_params=( --non-interactive )
    if [ ! -z "$CM_VCS_USERNAME" ]; then
        _svn_params+=( --no-auth-cache --username "$CM_VCS_USERNAME" --password "$CM_VCS_PASSWORD"  )
    fi

    # if using SSL with invalid certificate, need to pass --trust-server-cert argument
    if [[ "$_file" =~ ^https\:\/\/.* ]] && [ "$CM_VCS_ACCEPT_INVALID_SSL" = "true" ]; then
        _svn_params+=('--trust-server-cert')
    fi
    if [ "$verbose_mode" -eq 1 ]; then
        svn export -r "$CM_VCS_REVISION" "${_svn_params[@]}" "$_file"
    else
        svn export -r "$CM_VCS_REVISION" "${_svn_params[@]}" "$_file" >>"$cmbootstrap_log_path" 2>>"$cmbootstrap_err_path"
    fi

}


# Git functions
# --------------------------------------------------------------------------------
function installGit() {

    logInfo 'Installing Git...'

    installPackage "$git_version"

    # delete old Git clone path if it exists
    rm -rf "$git_clone_tmp_path"

}
function gitCheckFileExists {

    local _file=$1
    local _file_local_path

    gitClone

    # build path to the file in the local repository clone
    _file_local_path="${_file/$CM_VCS_REPO_BASE/$git_clone_tmp_path}"

    logInfo "Checking for Git file: $_file_local_path"

    ls "$_file_local_path" > /dev/null 2>&1

}
function gitRetrieveFile {

    local _file=$1
    local _file_local_path

    gitClone

    # build path to the file in the local repository clone
    _file_local_path="${_file/$CM_VCS_REPO_BASE/$git_clone_tmp_path}"

    cp "$_file_local_path" .

}
function gitClone {

    local _git_repo_with_auth
    local _git_additional_params

    if [ -d "$git_clone_tmp_path" ]; then
        return
    fi

    # additional GIT parameters to perform shallowest possible clone
    if [ ! -z "$CM_VCS_BRANCH" ]; then
        logInfo "Cloning Git branch '$CM_VCS_BRANCH'"
        _git_additional_params=( --branch "$CM_VCS_BRANCH" )
    fi
    if [ "$CM_VCS_REVISION" = "$default_vcs_revision" ]; then
        logInfo "Performing shallow (depth 1) Git clone"
        _git_additional_params+=( --depth 1 )
    fi

    # insert authentication details into the repository URL
    if [ ! -z "$CM_VCS_USERNAME" ]; then
        _git_repo_with_auth="${CM_VCS_REPO_BASE/https:\/\//https://$CM_VCS_USERNAME:$CM_VCS_PASSWORD@}"
        _git_repo_with_auth="${_git_repo_with_auth/http:\/\//http://$CM_VCS_USERNAME:$CM_VCS_PASSWORD@}"
    fi

    # if the Git repository has not already been retrieved, clone it to the temporary location
    if [ ! -d "$git_clone_tmp_path" ]; then
        logInfo "Cloning Git repository $CM_VCS_REPO_BASE to $git_clone_tmp_path."
        makeDirectory "$git_clone_tmp_path"
        if [ "$verbose_mode" -eq 1 ]; then
            git clone "${git_params[@]}" "${_git_additional_params[@]}" "$_git_repo_with_auth" "$git_clone_tmp_path/"
        else
            git clone "${git_params[@]}" "${_git_additional_params[@]}" "$_git_repo_with_auth" "$git_clone_tmp_path/" >>"$cmbootstrap_log_path" 2>&1
        fi
    fi
    if [ $? -ne 0 ]; then
        fatalError 'Error cloning Git repository, terminating.' 91
    fi

    if [ "$CM_VCS_REVISION" != "$default_vcs_revision" ]; then
        logInfo "Switching '$git_clone_tmp_path' to revision '$CM_VCS_REVISION'."
        git -C "$git_clone_tmp_path" checkout "$CM_VCS_REVISION"
    fi

    # export Git clone path
    CM_VCS_GIT_CLONE_DIR="$git_clone_tmp_path"
    export CM_VCS_GIT_CLONE_DIR

}


# Ansible functions
# --------------------------------------------------------------------------------
function installAnsible() {

    # install Ansible
    if [ -z "$ansible_version" ]; then
        logInfo "Installing Ansible package..."
        installPackage "ansible$ansible_version"
    else
        # alternative versions of Ansible need to be installed using PIP
        logInfo "Installing Ansible version '$ansible_version' using PIP..."
        installPackage "python-pip"
        logInfo "Installing Ansible..."
        pip install "ansible==$ansible_version"
        if [ $? -ne 0 ]; then
            fatalError 'Error PIP installing Ansible, terminating.' 111
        fi
    fi

    # remove example Ansible hosts file, which contains unwanted example
    # hosts such as 'alpha.example.org', and replace with localhost only
    rm "$ansible_hosts_file" 2>/dev/null
    makeDirectory "$ansible_hosts_path"
    echo "localhost" > "$ansible_hosts_file"

}
function ansibleRun {

    if [ "$verbose_mode" -eq 1 ]; then
        ansible-playbook --connection=local "$1"
    else
        ansible-playbook --connection=local "$1" >>"$ansible_log_path" 2>>"$ansible_err_path"
    fi
}


# local configuration management file check functions
# --------------------------------------------------------------------------------
function checkIfLocalCmInitFileExists() {

    if [ -f "$local_ansible_init_file" ]; then
        return 1
    else
        return 0
    fi

}
function checkIfLocalCmMainFileExists() {

    if [ -f "$local_ansible_main_file" ]; then
        logInfo "Local configuration file '$local_ansible_main_file' found."
        return 1
    else
        logInfo "Local configuration file '$local_ansible_main_file' not found."
        return 0
    fi

}
function checkIfLocalCmFilesExist() {

    # is either a init or main file is found locally, then
    # consider local files to exist
    checkIfLocalCmInitFileExists
    if [ $? -eq 1 ]; then
        return 1
    fi
    checkIfLocalCmMainFileExists
    if [ $? -eq 1 ]; then
        return 1
    fi

}


# configuration file value retrieval
# --------------------------------------------------------------------------------
function readConfigFileValue() {

    local _configName=$1

    configValue=$(cat "$cmbootstrap_config_path" | grep "^$_configName\:" | awk -F':' '{ val = index($0,":");print substr($0,val+1)}')

    if [ ! -z "$configValue" ]; then
        logInfo "Config value $_configName='$configValue' retrieved."
    fi

}


# utility functions
# --------------------------------------------------------------------------------
function _cleanup() {

    # delete Git temporary clone path if created
    rm -rf "$git_clone_tmp_path"

}
function makeDirectory {
    mkdir -p $1
}
function windowsToUnixFormat {
    # remove any Windows newline characters from text file
    tr -d '\r' <"$1" > "$1.tmp"
    mv "$1.tmp" "$1"
}


# logging functions
# --------------------------------------------------------------------------------
function logInfo() {

    local _message=$1

    if [ "$verbose_mode" -eq 1 ]; then
        echo "$_message"
    else
        echo "$_message" >> "$cmbootstrap_log_path"
    fi

}
function logError() {

    local _message=$1

    if [ "$verbose_mode" -eq 1 ]; then
        echo "ERROR: $_message"
    else
        echo "$_message" >>"$cmbootstrap_err_path"
    fi

}
function fatalError() {

    local _message=$1
    local _exit_code=$2

    _cleanup

    logError "$_message"
    if [ "$verbose_mode" -ne 1 ]; then
        echo "$_message"
    fi
    addInstanceLabel 'cmbootstrap-failed'
    exit "$_exit_code"

}


# script compacting and escaping functions
# --------------------------------------------------------------------------------

# modify startup script by removing comments
# and blank lines and reducing whitespace
function createCompact() {

    sed -e 's/^[[:space:]]*#[^#!].*$//' "$script_dir$0" | sed -E 's/[[:space:]]+/ /' | sed -E 's/^[[:space:]]+//' | sed -E 's/[[:space:]]+$//' | grep '\S' > "$script_dir$0.compact"
    echo "'$script_dir$0' compacted to '$script_dir$0.compact'."
}

# modify startup script by escaping \\ to \, escaping "
# to  \", and by replacing all new line characters with "\n"
function createEscaped() {

    createCompact

    sed -e 's/\\/\\\\/g' "$script_dir$0.compact" | sed 's/\"/\\"/g' | sed -n -e 'H;${x;s/\n/\\n/g;p;}' > "$script_dir$0.escaped"

}


# main execution
# --------------------------------------------------------------------------------
args=("$@")
_configGeneral
_configPath
_init
# remove any labels that might have been previously set before labeling as started
removeInstanceLabel 'cmbootstrap-failed' 1
removeInstanceLabel 'cmbootstrap-completed' 1
removeInstanceLabel 'cmbootstrap-completed-previously' 1
addInstanceLabel 'cmbootstrap-started'
_retrieveMetaData
_setStaticIpAddress
_configVcs
_configCm
_configHostname
addInstanceLabel 'cmbootstrap-installing'
_installPrerequisites
_fetchFiles
addInstanceLabel 'cmbootstrap-configuring'
_runInitFile
_runMainFile
_cleanup
addInstanceLabel 'cmbootstrap-completed'
logInfo "Finished."
